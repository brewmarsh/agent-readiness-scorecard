import os
from pathlib import Path
from typing import List, Dict, Any, Optional, Union, cast
from .constants import DEFAULT_THRESHOLDS
from .types import (
    FileAnalysisResult,
    AnalysisResult,
    AdvisorFileResult,
    Profile,
    Thresholds,
)
from .report_sections import (
    generate_summary_section,
    generate_acl_section,
    generate_type_safety_section,
    generate_prompts_section,
    generate_file_table_section,
)


def generate_markdown_report(
    stats: List[FileAnalysisResult],
    final_score: float,
    path: Union[str, Path],
    profile: Profile,
    project_issues: Optional[List[str]] = None,
    thresholds: Optional[Thresholds] = None,
    verbosity: str = "detailed",
) -> str:
    """Orchestrates the Markdown report generation using modular components and verbosity logic."""
    actual_thresholds: Thresholds = thresholds or cast(
        Thresholds, DEFAULT_THRESHOLDS.copy()
    )

    # 1. Generate Executive Summary (Always present)
    summary = generate_summary_section(stats, final_score, profile, project_issues)
    
    # 2. Quiet Mode: Return early with just the score and status
    if verbosity == "quiet":
        return summary + "\n---\n*Generated by Agent-Scorecard*"

    # 3. Generate detailed sections with verbosity awareness
    # RESOLUTION: Delegated section generation to report_sections.py while passing verbosity flag
    targets = generate_acl_section(stats, actual_thresholds)
    types_section = generate_type_safety_section(stats, actual_thresholds, verbosity=verbosity)
    prompts = generate_prompts_section(stats, actual_thresholds, project_issues)
    table = generate_file_table_section(stats, verbosity=verbosity)

    return (
        summary
        + targets
        + types_section
        + prompts
        + "\n"
        + table
        + "\n---\n*Generated by Agent-Scorecard*"
    )


def generate_advisor_report(
    stats: List[AdvisorFileResult],
    dependency_stats: Dict[str, int],
    entropy_stats: Dict[str, int],
    cycles: List[List[str]],
) -> str:
    """Generates an advanced report focusing on architectural physics."""
    report = "# ðŸ§  Agent Advisor Report\n\nAnalysis based on the **Physics of Agent-Code Interaction**.\n\n"

    # 1. ACL Physics
    report += (
        "## 1. Agent Cognitive Load (ACL)\n*Formula: ACL = Complexity + (LOC / 20)*\n\n"
    )
    high_acl_files = sorted(
        [s for s in stats if s.get("acl", 0) > 15],
        key=lambda x: x.get("acl", 0),
        reverse=True,
    )
    if high_acl_files:
        report += "### ðŸš¨ Hallucination Zones (ACL > 15)\n| File | ACL | Complexity | LOC |\n|---|---|---|---|\n"
        for s in high_acl_files:
            report += f"| `{s['file']}` | **{s.get('acl', 0):.1f}** | {s.get('complexity', 0):.1f} | {s.get('loc', 0)} |\n"
    else:
        report += "âœ… No Hallucination Zones detected.\n"

    # 2. Context Economics
    report += "\n## 2. Context Economics\n"
    high_token_files = [f for f in stats if f.get("tokens", 0) > 32000]
    if high_token_files:
        report += "### ðŸª™ Token Budget (> 32k tokens)\n"
        for f in high_token_files:
            report += f"- `{f['file']}`: {f.get('tokens', 0)} tokens\n"
    else:
        report += "âœ… All files within context window limits.\n"

    # 3. Dependency Entanglement
    report += "\n## 3. Dependency Entanglement\n"
    god_modules = sorted(
        {k: v for k, v in dependency_stats.items() if v > 50}.items(),
        key=lambda x: x[1],
        reverse=True,
    )
    if god_modules:
        report += "### ðŸ•¸ God Modules\n| File | Inbound Refs |\n|---|---|\n"
        for k, v in god_modules:
            report += f"| `{k}` | {v} |\n"

    if cycles:
        report += "### ðŸ”„ Circular Dependencies\n"
        for cycle in cycles:
            report += f"- {' -> '.join(cycle)} -> {cycle[0]}\n"
    else:
        report += "âœ… No Circular Dependencies detected.\n"

    # 4. Directory Entropy
    # RESOLUTION: Combined visual table clarity with modular entropy logic from Beta branch.
    report += "\n## 4. Directory Entropy\n"
    crowded_dirs = {k: v for k, v in entropy_stats.items() if v > 15}
    if crowded_dirs:
        report += "### ðŸ“‚ Crowded Directories (> 15 files)\n| Directory | File Count |\n|---|---|\n"
        for k, v in crowded_dirs.items():
            report += f"| `{k}` | {v} |\n"
    else:
        report += "âœ… Directory structure is balanced.\n"

    return report


def generate_recommendations_report(
    results: Union[AnalysisResult, List[FileAnalysisResult]],
) -> str:
    """Creates a RECOMMENDATIONS.md file to guide systemic improvements."""
    recommendations = []
    file_list = (
        results.get("file_results", []) if isinstance(results, dict) else results
    )
    missing_docs = results.get("missing_docs", []) if isinstance(results, dict) else []

    for res in file_list:
        if res.get("complexity", 0) > 20:
            recommendations.append(
                {
                    "Finding": f"High Complexity: {res['file']}",
                    "Agent Impact": "Context window overflow.",
                    "Recommendation": "Refactor into pure functions.",
                }
            )

        issues_text = str(res.get("issues", ""))
        if "Circular dependency" in issues_text:
            recommendations.append(
                {
                    "Finding": f"Circular Dependency: {res['file']}",
                    "Agent Impact": "Recursive loops.",
                    "Recommendation": "Use Dependency Injection.",
                }
            )

        if res.get("type_coverage", 100) < 90:
            recommendations.append(
                {
                    "Finding": f"Low Type Safety: {res['file']}",
                    "Agent Impact": "Hallucination of signatures.",
                    "Recommendation": "Add PEP 484 hints.",
                }
            )

        # RESOLUTION: Preserve docstring logic for agent semantic understanding
        if "Missing docstrings" in issues_text:
            recommendations.append(
                {
                    "Finding": f"Missing Docstrings: {res['file']}",
                    "Agent Impact": "Agent misses semantic context of functions.",
                    "Recommendation": "Add triple-quote docstrings to all functions.",
                }
            )

    if any(doc.lower() == "agents.md" for doc in missing_docs):
        recommendations.append(
            {
                "Finding": "Missing AGENTS.md",
                "Agent Impact": "Agent guesses repository structure.",
                "Recommendation": "Create AGENTS.md with specific context.",
            }
        )

    if not recommendations:
        return "# Recommendations\n\nâœ… Your codebase looks Agent-Ready!"

    table = "| Finding | Agent Impact | Recommendation |\n| :--- | :--- | :--- |\n"
    for rec in recommendations:
        table += (
            f"| {rec['Finding']} | {rec['Agent Impact']} | {rec['Recommendation']} |\n"
        )

    return "# Recommendations\n\n" + table